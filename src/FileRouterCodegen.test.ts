import {
  expect,
  it,
} from "bun:test"
import * as NPath from "node:path"
import { parseRoute } from "./FileRouter.ts"
import type { RouteHandle } from "./FileRouter.ts"
import * as FileRouterCodegen from "./FileRouterCodegen.ts"

it("generates code for pages only", () => {
  const handles: RouteHandle[] = [
    parseRoute("_page.tsx"),
    parseRoute("about/_page.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/** 
 * Auto-generated by effect-bundler.
 * This file is created on startup and automatically updated when routes change
 * for all programs that use FileRouter.layer.
 */

  const page_ = {
  path: "/",
  parent: undefined,
  load: () => import("./_page.tsx"),
}

const page_about = {
  path: "/about",
  parent: undefined,
  load: () => import("./about/_page.tsx"),
}

export const Pages = [
  page_,
  page_about
] as const

export const Servers = [
  
] as const
 `

  expect(code)
    .toBe(expected)
})

it("generates code for server endpoints only", () => {
  const handles: RouteHandle[] = [
    parseRoute("api/_server.ts"),
    parseRoute("api/users/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/** 
 * Auto-generated by effect-bundler.
 * This file is created on startup and automatically updated when routes change
 * for all programs that use FileRouter.layer.
 */

  const server_api = {
  path: "/api",
  load: () => import("./api/_server.ts"),
}

const server_api_users = {
  path: "/api/users",
  load: () => import("./api/users/_server.ts"),
}

export const Pages = [
  
] as const

export const Servers = [
  server_api,
  server_api_users
] as const
 `

  expect(code)
    .toBe(expected)
})

it("generates code for mixed pages, layouts, and server endpoints", () => {
  const handles: RouteHandle[] = [
    parseRoute("_layout.tsx"),
    parseRoute("_page.tsx"),
    parseRoute("api/_server.ts"),
    parseRoute("dashboard/_layout.tsx"),
    parseRoute("dashboard/_page.tsx"),
    parseRoute("dashboard/api/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/** 
 * Auto-generated by effect-bundler.
 * This file is created on startup and automatically updated when routes change
 * for all programs that use FileRouter.layer.
 */

  const layout_ = {
  path: "/",
  parent: undefined,
  load: () => import("./_layout.tsx"),
}

const page_ = {
  path: "/",
  parent: layout_,
  load: () => import("./_page.tsx"),
}

const server_api = {
  path: "/api",
  load: () => import("./api/_server.ts"),
}

const layout_dashboard = {
  path: "/dashboard",
  parent: layout_,
  load: () => import("./dashboard/_layout.tsx"),
}

const page_dashboard = {
  path: "/dashboard",
  parent: layout_dashboard,
  load: () => import("./dashboard/_page.tsx"),
}

const server_dashboard_api = {
  path: "/dashboard/api",
  load: () => import("./dashboard/api/_server.ts"),
}

export const Pages = [
  page_,
  page_dashboard
] as const

export const Servers = [
  server_api,
  server_dashboard_api
] as const
 `

  expect(code)
    .toBe(expected)
})

it("handles dynamic routes in server endpoints", () => {
  const handles: RouteHandle[] = [
    parseRoute("api/users/$userId/_server.ts"),
    parseRoute("api/posts/$postId/comments/$commentId/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code).toContain("const server_api_users_$userId = {")
  expect(code).toContain(
    "const server_api_posts_$postId_comments_$commentId = {",
  )
  expect(code).toContain("path: \"/api/users/$userId\"")
  expect(code).toContain("path: \"/api/posts/$postId/comments/$commentId\"")
})

it("handles splat routes in server endpoints", () => {
  const handles: RouteHandle[] = [
    parseRoute("api/files/$/_server.ts"),
    parseRoute("proxy/$/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code).toContain("const server_api_files_$ = {")
  expect(code).toContain("const server_proxy_$ = {")
  expect(code).toContain("path: \"/api/files/$\"")
  expect(code).toContain("path: \"/proxy/$\"")
})

it("generates correct variable names for root routes", () => {
  const handles: RouteHandle[] = [
    parseRoute("_page.tsx"),
    parseRoute("_layout.tsx"),
    parseRoute("_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Root routes should have underscore after prefix (e.g., page_, layout_, server_)
  expect(code).toContain("const layout_ = {")
  expect(code).toContain("const page_ = {")
  expect(code).toContain("const server_ = {")
  expect(code).toContain("path: \"/\"")
})

it("generates empty exports when no handles provided", () => {
  const handles: RouteHandle[] = []

  const code = FileRouterCodegen.generateCode(handles)

  expect(code).toContain("export const Pages = [")
  expect(code).toContain("] as const")
  expect(code).toContain("export const Servers = [")
  expect(code).toContain("] as const")

  // Should not contain any const definitions
  expect(code).not.toMatch(/const (page|layout|server)_/)
})

it("getHandlePrefix returns correct prefixes for all handle types", () => {
  expect(FileRouterCodegen.getHandlePrefix("PageHandle")).toBe("page")
  expect(FileRouterCodegen.getHandlePrefix("LayoutHandle")).toBe("layout")
  expect(FileRouterCodegen.getHandlePrefix("ServerHandle")).toBe("server")
})

it("server endpoints don't include parent layout references", () => {
  const handles: RouteHandle[] = [
    parseRoute("dashboard/_layout.tsx"),
    parseRoute("dashboard/_page.tsx"),
    parseRoute("dashboard/api/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Page should reference layout as parent
  expect(code).toMatch(
    /const page_dashboard = \{[\s\S]*?parent: layout_dashboard/,
  )

  // Server should not reference parent (no parent property)
  expect(code).toMatch(
    /const server_dashboard_api = \{[\s\S]*?path: "\/dashboard\/api"[\s\S]*?load:/,
  )
  expect(code).not.toMatch(/const server_dashboard_api = \{[\s\S]*?parent:/)
})

it("maintains proper variable ordering in exports", () => {
  const handles: RouteHandle[] = [
    parseRoute("b/_page.tsx"),
    parseRoute("a/_page.tsx"),
    parseRoute("c/_server.ts"),
    parseRoute("a/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Variables should be generated based on the order they appear in handles array
  const pageExportMatch = code.match(
    /export const Pages = \[([\s\S]*?)\] as const/,
  )
  const httpExportMatch = code.match(
    /export const Servers = \[([\s\S]*?)\] as const/,
  )

  expect(pageExportMatch)
    .toBeTruthy()

  expect(httpExportMatch)
    .toBeTruthy()

  const pagesContent = pageExportMatch![1].trim()
  const httpContent = httpExportMatch![1].trim()

  // Check that pages are exported in the order they were processed

  expect(pagesContent)
    .toMatch(/page_b,\s*page_a/)

  // Check that servers are exported in the order they were processed

  expect(httpContent)
    .toMatch(/server_c,\s*server_a/)
})

it("generates proper code structure", () => {
  const handles: RouteHandle[] = [parseRoute("_page.tsx")]
  const code = FileRouterCodegen.generateCode(handles)

  // Should have proper structure

  expect(code)
    .toContain("const page_ = {")

  expect(code)
    .toMatch(
      /export const Pages = \[[\s\S]*?\] as const\s*\n\s*export const Servers = \[/,
    )
})

it("validateServerModule returns true for valid modules", () => {
  // HTTP verb exports

  expect(
    FileRouterCodegen.validateServerModule({
      GET: "handler",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      POST: "handler",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      PUT: "handler",
    }),
  )
    .toBe(true)

  expect(FileRouterCodegen.validateServerModule({
    DELETE: "handler",
  }))
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      PATCH: "handler",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      HEAD: "handler",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      OPTIONS: "handler",
    }),
  )
    .toBe(true)

  // Default export

  expect(
    FileRouterCodegen.validateServerModule({
      default: "handler",
    }),
  )
    .toBe(true)

  // Mixed exports

  expect(
    FileRouterCodegen.validateServerModule({
      GET: "get",
      POST: "post",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      GET: "get",
      default: "handler",
    }),
  )
    .toBe(true)
})

it("validateServerModule returns false for invalid modules", () => {
  // No valid exports

  expect(
    FileRouterCodegen.validateServerModule({}),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      someOtherExport: "value",
    }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      INVALID: "verb",
    }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      get: "lowercase",
    }),
  )
    .toBe(false)
})

it("validateServerModule edge cases", () => {
  // Case sensitivity

  expect(
    FileRouterCodegen.validateServerModule({
      get: "lowercase",
    }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      Get: "mixed",
    }),
  )
    .toBe(false)

  // Similar but invalid keys

  expect(
    FileRouterCodegen.validateServerModule({
      GETS: "plural",
    }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      DEFAULT: "uppercase",
    }),
  )
    .toBe(false)

  // Valid mixed with invalid

  expect(
    FileRouterCodegen.validateServerModule({
      GET: "valid",
      invalid: "key",
    }),
  )
    .toBe(true)
})

it("validates server module integration with generateCode", () => {
  // Test that server handles are properly processed in the code generation
  const handles = [
    parseRoute("api/_server.ts"),
    parseRoute("_page.tsx"),
    parseRoute("users/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Verify the generated code includes server endpoints

  expect(code)
    .toContain("const server_api = {")

  expect(code)
    .toContain("const server_users = {")

  expect(code)
    .toContain("export const Servers = [")

  expect(code)
    .toContain("server_api,")

  expect(code)
    .toContain("server_users")

  // Verify that server handles are correctly processed separate from pages

  expect(code)
    .toContain("const page_ = {")

  expect(code)
    .toContain("export const Pages = [")

  expect(code)
    .toContain("page_")
})

it("validation logic handles complex module structures", () => {
  // Test various realistic module export patterns

  // Multiple HTTP verbs
  const multiVerbModule = {
    GET: () => "get handler",
    POST: () => "post handler",
    someHelper: "utility function",
  }

  expect(
    FileRouterCodegen.validateServerModule(multiVerbModule),
  )
    .toBe(true)

  // Default with other exports
  const defaultWithOthers = {
    default: () => "default handler",
    middleware: () => "middleware",
    config: { timeout: 5000 },
  }

  expect(
    FileRouterCodegen.validateServerModule(defaultWithOthers),
  )
    .toBe(true)

  // Only utility exports (invalid)
  const utilityOnly = {
    helper: () => "helper",
    config: { port: 3000 },
    constants: ["a", "b", "c"],
  }

  expect(
    FileRouterCodegen.validateServerModule(utilityOnly),
  )
    .toBe(false)
})

it("validation works with realistic server module patterns", () => {
  // Simulate real Effect HttpApp patterns
  const effectServerModule = {
    GET: "HttpServerResponse.text('GET response')",
    POST: "Effect.gen(function*() { /* ... */ })",
    middleware: "some middleware function",
  }

  expect(
    FileRouterCodegen.validateServerModule(effectServerModule),
  )
    .toBe(true)

  // API route with fallback
  const apiRouteModule = {
    GET: "Effect.succeed(Response.json(data))",
    default: "Effect.gen(function*() { /* fallback */ })",
  }

  expect(
    FileRouterCodegen.validateServerModule(apiRouteModule),
  )
    .toBe(true)

  // Route with only non-HTTP exports (invalid)
  const invalidModule = {
    helper: () => {},
    config: {},
    utils: [],
  }

  expect(
    FileRouterCodegen.validateServerModule(invalidModule),
  )
    .toBe(false)
})
